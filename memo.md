- [ ] 0: design decision, what we do with the Failed PSM, should that be decided by caller, or should we retry automatically?
- [ ] 1: check SA grpc implementation, the whole, deep call stack
- [ ] 1: design a new mechanism for agency start cmd. Is it really needed that we can start it by all commands are flags in the runtime? If so, should we have two layer system where somekind of frontend parses the flags and send them as json struct when starting. Maybe we could find some kind of clever mechanism to build cmds which can be constructed from commandline or cfg file, but which would be simpler than current cobra.  
- [ ] 1: salt validation warning, or something else, in future we don't need to salt at all but at some point. we might be a similar thing with our JWT secret.
- [ ] 2: authenticator for SAs, how to build client for FIDO2
- [ ] 3: split `grpc_test.go` file 
- [ ] 3: start to make first version of the gRPC API as a release!!
- [ ] 3: we need the correct initial state in FSM, or this should be at least checked
- [ ] 4: move bot start cmds to CLI
- [ ] 9: add a handler or some sort of UI for waiting-state situation (what is this? does it mean the cli tool, or the API)
- [ ] 9: tell how important CLI is, we could even offer it as a base for Aries
- [ ] 9: when we will change interface between protocol processor and SA implementation
- [ ] 9: when we will drop legacy API from agency? this is important, we should not support 2 API, it's too much for us
- [ ] Check agent notifications and statuses 
- [ ] figure out how to test system where listeners and other parties are many
- [ ] how to solve persistence with chat bots. Especially, should they save their pairwise level conversations. If someone is coming back, can we take that data from there? We must test and see what is needed. Current key value map is live only under app life cycle.
- [ ] Idea: use plantuml format for state machines: if there is not enough experssions in the language we could have 2 files where other is plant uml for visualization, and the other is detailed descriptions for other stuff: named list of events or named list of transitions! plant file just names the transitions and other file describes what to do in the triggers and sends!! quite cool.
- [ ] input message source could be URL's e.g. when we send pin code for email it could be inside a link which would direct right to us. But note, if we are doing chat bot, it doesn't do everything in the world, dosen't it?
- [ ] new settings for gRPC agency and clients: tls cert and key file locations, address and port file locations, could that be a config file or should we stay with single envs and cmd flags?
- [ ] old trust ping command says nothing on success
- [ ] performance optimization potential is in agency by not read all the PSM access from Bolt but from memory
- [ ] performance optimization potential is in agency by not writing so many state transitions to the DB
- [ ] psm rm: move current PSMhook clean up of `Archived` PSM and related REP to a background service
- [ ] remember to check the command structure, should we have the same structures for both commands and have only some global flag to switch between modes
- [ ] restructuring long testfiles like grpc_test.go: idea reuse testMainSuff, generalize them that you can split test files
- [ ] sa communication, the question, if multiple clients want to answer, no we have 1on1 with questions and answers. Maybe should have RmQuestion api for handling that? I don't remember what this means anymore ... Now I do. User could have iPad and iPhone and wants to answer one of them. Both should have the question thought.
- [ ] should we be able to listen one pairwise, and everything what's happening for it. Now we can listen our CA, but with gRPC should we be able to listen that too? we can listen one protocol when we are starting it by us with the **Run** function. does this bring more complexity to agency, or not? at least with other languages which don't have same concurrency as Go has it might help?
- [ ] should we move Aries specific message structs a somewhere generic repo, we don't want to have dependencies to agency, good-one! should we even start to move some stuff out of agency for that same reason?
- [ ] started: list all secrets like JWT generation key, all enclave keys, ...
- [ ] use exactly same Cmds as previously, but internally switch to use wallet+key or CA-DID / jwt token, this is the best version!!! have to make a design for the implementation.
- [ ] we have wrong error handling in bolt database, it reports error when it is not founding data!!
- [ ] what whould be a good demo?
- [x] 0: a test in a playground what happens when output interface is assigned to output interface. how it will be from outside? DONE: only the interface value is transported which should affect that if you try to change something after the pointer switch you set wrong variable!!
- [x] 0: correct garbage collection mistake in bolt db handling!! Integrate the Bold refactoring.
- [x] 0: Give() grpc API function doesn't return any ID info, not error, but result is empty
- [x] 0: inputs to input in fsm answer building
- [x] 0: refactor all Bold db stuff to same interface as grpc/enclave is
- [x] add API for giving permission to continue protocol. in progress...
- [x] addon for ledger: should load all of them when addon directory is imported
- [x] build archiving aka protocol.Release() ready, remove the PSM from data base, maybe we need another state for that Archived -> removed. DONE1, `Archived` added, missing actual cleanup
- [x] check grpc loggings
- [x] check protocol role! Especially when we are getting notifications from PSM we must know what is going on at that level!!
- [x] cleanup ONEfindy.json and build mechanism reset it back after its dirty. this could be a manual job
- [x] commit new scripts and write documentation to README.md 
- [x] could we use mime type for SA endpoints, by this we could use same wallet storage and logic for them as well
- [x] DONE: this works because `om` was returned from function: fix the `im=om` bug in the SA implementers!! DONE2: will remove the assings and test then, DONE3: was misreading, `om` is return value, we dont have cloning mechanis, so we reuse `im` and comment it. When old indy messages are obsolete, this will go away
- [x] enclave cryptos, all cryptos we have: first proper implementation to grpc repo
- [x] ERR and NACK results of ProtocolState should be handled differently. Done
- [x] Fix the only one issue of the Agency
- [x] **found solution which is generic** every grpc-function in service must be protected by err2.Catch aka recovery, they are in own goroutines, panics will crash the whole server
- [x] how to merge question/answer to listen/resume pair, we have same listener but how about continue? we have different .proto files. we must merge the notification types atleast! **we keep these different at least for the moment. this means that need actions and answer required are different and answering to them need to use different apis, even the listening can be done with the same function**
- [x] **how we will implement the on boarding in grpc** that will lead to everything, how we will implement the everything!!, we did use previous mechanism for onboarding. Made gRPC API which uses one EA wallet for all.
- [x] implementation ID (permissive, grpc, ..) must be saved to wallet. **Done** by saving grpc id's to same endpoints by using sheme of endpoint url like grpc://localhost
- [x] initially tested to use only one EA client wallet which worked just fine. EA wallets have only pairwises to CA stored to them. that seems to be enouhg
- [x] `jwt status` returns plain json, should we start to use types finally i.e. start to typing the status information!
- [x] jwt status won't return the information that PSM is waiting action, or is it? Should be. **Done: was missing handling, had to update API**
- [x] logging update from remotely
- [x] **nice** test use of config files with CLI, if we have env variable just for cfg file that file could be per directory which would allow us another way to have directory based context for CLI
- [x] performance optimization potential is in agency by transferring PW name from processor to input/output function
- [x] **proof ready, agent notification role was addressee, which was wrong, protocol status return correct one which was initiator** we start with this now.
- [x] psm rm: add rm functionality to Bold solution. DONE: psm with reps is implemented.
- [x] remember Step() call in answers
- [x] remember why it's good to have as simple as possible interface, but still extensible! it's more important even than easy to use.
- [x] run some sort of perf test to show the advances of the gRPC, comparison isn't done but Ge benchmark is written to new tests.
- [x] SA communication via Go channels need timeouts
- [x] send at the beginning of the FSM one event that will allow print Hello msg or similar
- [x] should we start to build own cli for agent-grpc project? easier debug and start, now I have used findy-service-tool, good question, how we will handle the meanwhile situation. DONE: move commands to CLI
- [x] start to think how we will offer gRPC APIs for clients in agency, and same time start to think how we will make unit testing for this system. we can do that similarly we have done it before i.e. we just build the whole wallet system for the tests, that's it! and use memory communication for the gRPC testing. **we don't use cmds for everything because it's not convenient for the client use. we make client API for EA implementation which make their life as easy as possible **
- [x] start to write chat-bot framework!! almost ready.
- [x] **testing is still needed** but all EAs can now work as issuer and verifier because of new gRPC API 
- [x] test other Status getters of grpc implementation, now we have basic-message, some is tested, had to check if automated tests are on.
- [x] think about a situation where we must find the existing PSM and operate with it, continue, cancel, etc.
- [x] unit tests for all API functions similarly as for previous Cmds, should be keep Cmds API as well? Or should we rewrite old commands with these new ones. **no we have separated APIs because we want to offer as easy to use as possible. that's why we need separated tests as well**
- [x] update `findy-grpc` README.md
- [x] value based basic message: by giving a certain key word different state transition will be triggered
- [x] **we did use only one client wallet for onboarding AND that's possible because client wallet only stores the pairwise key**
- [x] we have a spec from CLA BOT, 1. show invitation 2. wait connection to fulfill 3. send proof request 4. wait ACK 5. grant access if ok ack 6. denie access. WE NEED the fucking state machine!!!
- [x] what happens if client just brakes the connection in the middle of the protocol like when waiting state is coming! Answer: gRPC handles it similarly as with the context
- [ ] Z: how to make sure that grpc impl SA handler doesn't eat memory? if no one is waiting for the question, it will wait for as long as the timeout says and it's taking one goroutine for that! Should we have another time out which would PING the log? We need a mechanism to Alert controler, like APNS
